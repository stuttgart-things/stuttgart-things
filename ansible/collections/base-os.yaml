---
name: base_os
version: 0.5.30
namespace: sthings
requirements: |
  roles:
    - src: https://github.com/stuttgart-things/download-install-binary.git
      scm: git
      version: 2024.07.01
    - src: https://github.com/stuttgart-things/create-os-user.git
      scm: git
      version: 2024.05.03
    - src: https://github.com/stuttgart-things/install-requirements.git
      scm: git
      version: 2024.05.11
    - src: https://github.com/stuttgart-things/manage-filesystem.git
      scm: git
      version: 2024.06.07
    - src: https://github.com/stuttgart-things/install-configure-vault.git
      scm: git
      version: 2022.01.01
    - src: https://github.com/stuttgart-things/create-send-webhook.git
      scm: git
      version: 2024.06.06
    - src: https://github.com/stuttgart-things/manage-proxmox-resources.git
      scm: git
      version: 2024.05.27

playbooks:
  - name: setup
    play: |
      ---
      - hosts: "{{ target_host | default('all') }}"
        become: true
        gather_facts: true

        vars:
          manage_filesystem: true
          update_packages: true
          install_requirements: true
          install_motd: true
          reboot_all: false
          username: sthings
          lvm_home_sizing: "15%"
          lvm_root_sizing: "35%"
          lvm_var_sizing: "50%"
          send_to_msteams: true
          msteams_webhook_url: "https://365sva.webhook.office.com/webhookb2/2f14a9f8-4736-46dd-9c8c-31547ec37180@0a65cb1e-37d5-41ff-980a-647d9d0e4f0b/IncomingWebhook/37a805a0a2624dc2ac1aedd7dec6ad49/dc3a27ed-396c-40b7-a9b2-f1a2b6b44efe"
          vault_instances:
            - https://vault.tiab.labda.sva.de:8200
            - https://vault.labul.sva.de:8200
            - https://vault-vsphere.labul.sva.de:8200
            - https://vault-pve.labul.sva.de:8200
            - https://vault-vsphere.tiab.labda.sva.de:8200
          python_modules:
            - name: boto3
              version: 1.34.119

        roles:
          - role: sthings.base_os.manage_filesystem
            when: manage_filesystem|bool

          - role: sthings.base_os.install_requirements
            when: install_requirements|bool

        pre_tasks:
          - name: Include vars
            ansible.builtin.include_vars: "{{ path_to_vars_file }}.yaml"
            when: path_to_vars_file is defined

          - ansible.builtin.reboot:
            when: reboot_all|bool

        tasks:
          - name: Install vault ca certificate to local system from multiple instances
            ansible.builtin.include_role:
              name: sthings.base_os.install_configure_vault
              tasks_from: install-ca-auth
            vars:
              vault_url: "{{ vault_instance }}"
            loop: "{{ vault_instances }}"
            loop_control:
              loop_var: vault_instance
            when: vault_instances is defined

          - name: Send webhook to msteams
            ansible.builtin.include_role:
              name: sthings.base_os.create_send_webhook
            vars:
              summary_text: base-os-setup was executed
              msteams_url: "https://365sva.webhook.office.com/webhookb2/2f14a9f8-4736-46dd-9c8c-31547ec37180@0a65cb1e-37d5-41ff-980a-647d9d0e4f0b/IncomingWebhook/37a805a0a2624dc2ac1aedd7dec6ad49/dc3a27ed-396c-40b7-a9b2-f1a2b6b44efe"
              card_title: base-os-setup was executed
              act_image: "{{ logo_pic }}"
              act_title: "{{ quotes | random }}"
              act_text: "{{ quotes | random }}"
              os_facts: |
                base-os-setup was executed on "{{ ansible_fqdn }}"
              ms_teams_notification_type: "simple"
            tags: notify
            ignore_errors: true
            when: send_to_msteams|bool

  - name: ansible
    play: |
      ---
      - hosts: "{{ target_host | default('all') }}"
        become: true
        gather_facts: true

        vars:
          update_packages: true
          ansible_username: sthings
          os_packages:
            - sshpass

          python_modules:
            - name: ansible
              version: 9.6.0
            - name: kubernetes
              version: 29.0.0
            - name: openshift
              version: 0.13.2
            - name: hvac[parser]
              version: 2.2.0
            - name: pyvmomi
              version: 8.0.2.0.1

        roles:
          - install-requirements

        post_tasks:
          - name: Download requirements file from git
            uri:
              url: https://raw.githubusercontent.com/stuttgart-things/stuttgart-things/main/ansible/requirements.yaml
              dest: /tmp/requirements.yaml

          - name: Install requirements
            ansible.builtin.shell: |
              ansible --version
              ansible-galaxy install -r /tmp/requirements.yaml -f
            become_user: "{{ ansible_username }}"

  - name: kcl
    play: |
      ---
      - hosts: "{{ target_host | default('all') }}"
        become: true

        tasks:
          - name: Install kcl-cli
            ansible.builtin.shell: |
              wget -q https://kcl-lang.io/script/install-cli.sh -O - | /bin/bash

  - name: golang
    play: |
      ---
      - hosts: "{{ target_host | default('all') }}"
        become: true
        vars:
          golang_version: 1.22.4
          #golang_checksum: 5fb8b3ed4a78a8eab444dfcb472b8c07a06980dcaee62ce3645edd6d130004c6 #1.22.3
          go_checksum_type: "sha256"
          source_url: "https://go.dev/dl/go{{ golang_version }}.linux-amd64.tar.gz"
          golang_install_dir: /usr/local
          golangci_version: 1.59.1 # datasource=github-tags depName=golangci/golangci-lint
          goreleaser_version: 1.26.2 # datasource=github-tags depName=goreleaser/goreleaser
          ko_version: v0.15.4 # datasource=github-tags depName=ko-build/ko

          # USE WITH EXISTING USER
          go_username: sthings
          go_usergroup: sthings
          go_userhome: /home/sthings

          bin:
            goreleaser:
              bin_name: goreleaser
              bin_version: "{{ goreleaser_version }}"
              check_bin_version_before_installing: true
              source_url: "https://github.com/goreleaser/goreleaser/releases/download/v{{ goreleaser_version }}/goreleaser_Linux_x86_64.tar.gz"
              bin_to_copy: goreleaser
              to_remove: goreleaser_Linux_x86_64.tar.gz
              bin_dir: "/usr/local/bin"
              version_cmd: "-- version"
              target_version: "{{ goreleaser_version }}"
            ko:
              bin_name: ko
              bin_version: "{{ ko_version }}"
              check_bin_version_before_installing: true
              source_url: "https://github.com/ko-build/ko/releases/download/{{ ko_version }}/ko_Linux_x86_64.tar.gz"
              bin_to_copy: ko
              to_remove: ""
              bin_dir: "/usr/bin/ko"
              version_cmd: "version"
              target_version: "{{ ko_version }}"

        pre_tasks:
          - name: Check if Golang is already installed
            ansible.builtin.stat:
              path: "{{ golang_install_dir }}/go"
            register: check_golang

          - name: Get checksum of golang dir
            sthings.base_os.get_checksum:
              path: "{{ golang_install_dir }}/go"
              checksum_type: "{{ go_checksum_type }}"
            register: checksum_existing
            when: check_golang.stat.exists or golang_checksum is defined

          - name: Create golang users
            ansible.builtin.include_role:
              name: create-os-user
            vars:
              users: "{{ golang_users }}"
              groups_to_create: "{{ groups_golang }}"
            when: golang_users is defined

          - name: Install golang
            block:
              - name: Delete existing Golang install
                ansible.builtin.file:
                  path: "{{ golang_install_dir }}/go"
                  state: absent

              - name: Unarchive Golang
                ansible.builtin.unarchive:
                  src: "{{ source_url }}"
                  dest: "{{ golang_install_dir }}/"
                  mode: 0755
                  validate_certs: false
                  remote_src: true
            when: golang_checksum is not defined or checksum_existing.checksum_value is not defined or golang_checksum != checksum_existing.checksum_value

          - name: Add golang exports for existing users to bashrc
            ansible.builtin.blockinfile:
              block: |
                export GOROOT=/usr/local/go
                export PATH=$GOROOT/bin:$PATH
                export GOPATH=$HOME/usr/local/go
                export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin
              dest: "{{ go_userhome }}/.bashrc"
              owner: "{{ go_username }}"
              group: "{{ go_usergroup }}"
              marker_begin: "<!-- BEGIN GOLANG SETUP -->"
              marker_end: "<!-- END GOLANG SETUP -->"
              mode: 0644
              create: true
            when: go_username is defined and go_usergroup is defined and go_userhome is defined

        post_tasks:
          - name: Install addons
            ansible.builtin.shell: |
              ./go install github.com/spf13/cobra-cli@v1.3.0
              ./go install github.com/golangci/golangci-lint/cmd/golangci-lint@{{ golangci_version }}
            args:
              chdir: "{{ golang_install_dir }}/go/bin/"

        roles:
          - role: sthings.base_os.download_install_binary

  - name: binaries
    play: |
      ---
      - hosts: "{{ target_host | default('all') }}"
        become: true
        vars:
          download_dir: "/tmp/downloads"

        vars_files:
          - "{{ path | default('.') }}/{{ profile | default('binaries') }}.yaml"

        roles:
          - role: sthings.base_os.download_install_binary

  - name: users
    play: |
      ---
      - hosts: "{{ target_host | default('all') }}"
        gather_facts: true
        become: true
        vars_files:
          - "{{ profile | default('users') }}.yaml"

        roles:
          - role: sthings.base_os.create_os_user

  - name: rename_proxmox_vm
    play: |
      ---
      - hosts: "{{ target_host | default('all') }}"
        vars:
          vault_approle_id: "{{ lookup('env', 'VAULT_ROLE_ID') }}"
          vault_approle_secret: "{{ lookup('env', 'VAULT_SECRET_ID') }}"
          vault_url: "{{ lookup('env', 'VAULT_ADDR') }}"

          pve_cluster_url: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=cloud/data/pve:cluster_url validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
          pve_api_user: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=cloud/data/pve:api_user validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
          pve_api_password: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=cloud/data/pve:api_password validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
          pve_node: sthings-pve1

          pve_bulk_rename_vms:
            - current_vm_name: "{{ vmname_old }}"
              expected_vm_name: "{{ vmname_new }}"
              node: "{{ pve_node }}"

        roles:
          - role: sthings.base_os.manage_proxmox_resources

  - name: delete_proxmox_vm
    play: |
      ---
      - hosts: "{{ target_host | default('all') }}"
        vars:
          vault_approle_id: "{{ lookup('env', 'VAULT_ROLE_ID') }}"
          vault_approle_secret: "{{ lookup('env', 'VAULT_SECRET_ID') }}"
          vault_url: "{{ lookup('env', 'VAULT_ADDR') }}"

          pve_cluster_url: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=cloud/data/pve:cluster_url validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
          pve_api_user: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=cloud/data/pve:api_user validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
          pve_api_password: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=cloud/data/pve:api_password validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
          pve_node: sthings-pve1

          pve_bulk_delete_vms:
            - name: "{{ vmname_delete }}"
              node: "{{ pve_node }}"

        roles:
          - role: sthings.base_os.manage_proxmox_resources

  - name: render_upload_vm
    play: |
      ---
      - hosts: "{{ target_host | default('localhost') }}"
        vars:
          vault_approle_id: "{{ lookup('env', 'VAULT_ROLE_ID') }}"
          vault_approle_secret: "{{ lookup('env', 'VAULT_SECRET_ID') }}"
          vault_url: "{{ lookup('env', 'VAULT_ADDR') }}"
          AWS_ACCESS_KEY_ID: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=apps/data/artifacts:accessKey validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
          AWS_SECRET_ACCESS_KEY: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=apps/data/artifacts:secretKey validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
          bucket_name: andre-vm-config
          rendered_all: "tf-config-all.tf"
          bucket_permission: [private]
          path: "vars"
          s3: "andre-dev"

          #-e lab=labul -e cloud=vsphere -vv

        vars_files:
          - "{{ path | default('.') }}/{{ lab }}.yaml"
          - "{{ path | default('.') }}/{{ cloud }}.yaml"
          - "{{ path | default('.') }}/s3-instances.yaml"
          - "{{ path | default('.') }}/vm-defaults.yaml"

        tasks:
          - name: Create a config file from a j2 template
            ansible.builtin.template:
              src: "{{ item.value.name }}.yaml"
              dest: "{{ ansible_date_time.date }}-{{ item.value.name }}.tf"
            loop: "{{ lookup('dict', j2_template_name, wantlist=True) }}"

          - name: Concat template files
            ansible.builtin.lineinfile:
              create: true
              path: "{{ rendered_all }}"
              line: "{{ lookup('file', '{{ ansible_date_time.date }}-vm-{{ cloud }}.tf') }}\n\n{{ lookup('file', '{{ ansible_date_time.date }}-backend.tf') }}"

          - name: Upload config to S3 Bucket
            amazon.aws.s3_object:
              bucket: "{{ bucket_name }}"
              object: "{{ ansible_date_time.date }}-{{ vmName }}.tf"
              src: "{{ rendered_all }}"
              mode: put
              access_key: "{{ AWS_ACCESS_KEY_ID }}"
              secret_key: "{{ AWS_SECRET_ACCESS_KEY }}"
              validate_certs: false
              encrypt: false
              rgw: false
              permission: "{{ bucket_permission }}"
              endpoint_url: "{{ instances[s3]['url'] }}"

          - name: Remove rendered vm config
            ansible.builtin.file:
              path: "{{ ansible_date_time.date }}-{{ item.value.name }}.tf"
              state: absent
            loop: "{{ lookup('dict', j2_template_name, wantlist=True) }}"

          - name: Remove concatenated template file
            ansible.builtin.file:
              path: "{{ rendered_all }}"
              state: absent

  - name: get_execute_terraform
    play: |
      ---
      - hosts: "{{ target_host | default('localhost') }}"
        vars:
          vault_approle_id: "{{ lookup('env', 'VAULT_ROLE_ID') }}"
          vault_approle_secret: "{{ lookup('env', 'VAULT_SECRET_ID') }}"
          vault_url: "{{ lookup('env', 'VAULT_ADDR') }}"
          state: "present"
          cloud: "vsphere"
          tf_vars_file: "{{ tf_vars }}"
          bucket_permission: [private]
          path: "vars"
          install_terraform: "true"
          s3: "andre-dev"

          bin:
            terraform:
              bin_name: "terraform"
              bin_version: "1.9.0"
              check_bin_version_before_installing: true
              source_url: "https://releases.hashicorp.com/terraform/1.9.0/terraform_1.9.0_linux_amd64.zip"
              bin_to_copy: "terraform"
              to_remove: "terraform"
              bin_dir: "/usr/local/bin"
              version_cmd: " --version"
              target_version: v1.9.0

        vars_files:
          - "{{ path | default('.') }}/terraform-vars.yaml"
          - "{{ path | default('.') }}/s3-instances.yaml"
          - "{{ path | default('.') }}/tf-vars-{{ cloud }}.yaml"

        environment:
          AWS_ACCESS_KEY_ID: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=apps/data/artifacts:accessKey validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
          AWS_SECRET_ACCESS_KEY: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=apps/data/artifacts:secretKey validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"

        pre_tasks:
          - name: call role and install terraform
            ansible.builtin.include_role:
              name: sthings.base_os.download_install_binary
              apply:
                become: true
            when: install_terraform|bool and state == "present"

        tasks:
          - name: Create terraform dir
            ansible.builtin.file:
              path: "{{ tf_project_path }}"
              state: directory
              mode: '1777'

          - name: Create project_name dir
            ansible.builtin.file:
              path: "{{ tf_project_path }}/{{ project_name }}"
              state: directory
              mode: '1777'

          - name: Get rendered vm config file f s3 bucket
            amazon.aws.s3_object:
              bucket: "{{ bucket_name }}"
              object: "{{ object_name }}"
              dest: "{{ tf_project_path }}/{{ project_name }}/{{ rendered_all }}"
              mode: get
              access_key: "{{ AWS_ACCESS_KEY_ID }}"
              secret_key: "{{ AWS_SECRET_ACCESS_KEY }}"
              validate_certs: false
              encrypt: false
              rgw: false
              permission: "{{ bucket_permission }}"
              endpoint_url: "{{ instances[s3]['url'] }}"

          - name: Init and apply terraform
            community.general.terraform:
              project_path: "{{ tf_project_path }}/{{ project_name }}"
              state: "{{ state }}"
              force_init: "{{ force_init }}"
              init_reconfigure: "{{ init_reconfigure }}"
              complex_vars: true
              variables: "{{ tf_vars_file }}"

templates:
  - name: vm-vsphere
    file: |
      module {{ vmName }} {
        source                 = "{{ tf_module_source }}"
        vm_count               = {{ vmCount }}
        vsphere_vm_name        = "{{ vmName }}"
        vm_memory              = {{ vm_memory }}
        vsphere_vm_template    = "{{ vm_template }}"
        vm_disk_size           = "{{ vm_disk }}"
        vm_num_cpus            = {{ vm_cpu }}
        firmware               = "{{ vmFirmware }}"
        vsphere_vm_folder_path = "{{ rootFolderpath }}/{{ folderpath }}"
        vsphere_datacenter     = "{{ datacenter }}"
        vsphere_datastore      = "{{ vm_datastores }}"
        vsphere_resource_pool  = "{{ resourcePool }}"
        vsphere_network        = "{{ vm_network }}"
        bootstrap              = ["echo STUTTGART-THINGS"]
        annotation             = "VSPHERE-VM {{ vmName }} {{ vmTemplate }} BUILD w/ TERRAFORM FOR STUTTGART-THINGS"
        vsphere_server         = var.vsphere_server
        vsphere_user           = var.vsphere_user
        vsphere_password       = var.vsphere_password
        vm_ssh_user            = var.vm_ssh_user
        vm_ssh_password        = var.vm_ssh_password
      }

      variable "vsphere_server" {
        default     = false
        type        = string
        description = "name of vsphere vm server"
      }

      variable "vm_ssh_user" {
        default     = false
        type        = string
        description = "username of ssh user for vm"
      }

      variable "vm_ssh_password" {
        default     = false
        type        = string
        description = "password of ssh user"
        }

      variable "vsphere_user" {
        default     = false
        type        = string
        description = "password of vsphere user"
      }

      variable "vsphere_password" {
        default     = false
        type        = string
        description = "password of vsphere user"
      }

      output "ip" {
        value = [module.{{ vmName }}.ip]
      }

  - name: vm-proxmox
    file: |
      module "{{ vmName }}" {
        source                  = "{{ tf_module_source }}"
        vm_count                = {{ vmCount }}
        vm_name                 = "{{ vmName }}"
        vm_memory               = "{{ vm_memory }}"
        vm_num_cpus             = "{{ vm_cpu }}"
        vm_disk_size            = "{{ vm_disk }}G"
        vm_template             = "{{ vm_template }}"
        pve_cluster_node        = "{{ datacenter }}"
        pve_datastore           = "{{ vm_datastores }}"
        pve_folder_path         = "{{ folderpath }}"
        pve_network             = "{{ vm_network }}"
        vm_notes                = "VSPHERE-VM {{ vmName }} {{ vm_template }} BUILD w/ TERRAFORM FOR STUTTGART-THINGS"
        pve_api_url             = var.pve_api_url
        pve_api_user            = var.pve_api_user
        pve_api_password        = var.pve_api_password
        vm_ssh_user             = var.vm_ssh_user
        vm_ssh_password         = var.vm_ssh_password
      }

      output "ip" {
        value     = module.{{ vmName }}.ip
      }

      variable "pve_api_url" {
        type        = string
        description = "url of proxmox api. Example: https://server-example.sva.de:8006/api2/json"
      }

      variable "pve_api_user" {
        type        = string
        description = "username of proxmox api user"
      }

      variable "pve_api_password" {
        type        = string
        description = "password of proxmox api user"
      }

      variable "vm_ssh_user" {
        type        = string
        description = "desired username for ssh connection"
      }

      variable "vm_ssh_password" {
        type        = string
        description = "desired password for ssh connection"
      }

  - name: backend
    file: |
      terraform {
        backend "s3" {

          endpoints = {
            s3 = "{{ backend_host_url }}"
          }

          skip_requesting_account_id = true
          skip_s3_checksum = true
          key = "{{ vmName }}.tfstate"
          bucket = "{{ bucket_name }}"
          region = "main"
          skip_credentials_validation = true
          skip_metadata_api_check = true
          skip_region_validation = true
          force_path_style = true
          workspace_key_prefix = "{{ vmName }}"
        }
      }

vars:
  - name: labul
    file: |
      ---
      lab_values:
        vsphere:
          template:
            ubuntu22: "sthings-u22"
            ubuntu24: "sthings-u24"
            rocky9: "sthings-r9"
          datastore:
            - "/LabUL/datastore/UL-ESX-SAS-01"
            - "/LabUL/datastore/UL-ESX-SAS-02"
            - "/LabUL/datastore/UL-V5010-01-LUN1"
            - "/LabUL/datastore/UL-V5010-01-LUN2"
            - "/LabUL/datastore/UL-V5010-01-LUN3"
          network:
            - "/LabUL/network/MGMT-10.31.101"
            - "/LabUL/network/LAB-10.31.102"
            - "/LabUL/network/LAB-10.31.103"
            - "/LabUL/network/LAB-10.31.104"
          subfolderpath: "testing"
          bucket_name: "andre-vm-config"
        proxmox:
          template:
            ubuntu22: "ubuntu22"
            ubuntu24: "ubuntu24"
            rocky9: "rocky9"
          datastore:
            - "v3700"
            - "datastore"
          network:
            - "vmbr101"
            - "vmbr102"
            - "vmbr103"
            - "vmbr104"
          subfolderpath: "stuttgart-things"
          bucket_name: "andre-vm-config"

  - name: vm-defaults
    file: |
      ---
      vm_size:
        cpu:
          s: 2
          m: 4
          l: 6
          xl: 8
        memory:
          s: 4096
          m: 6144
          l: 8192
          xl: 12288
        disk:
          s: 32
          m: 64
          l: 96
          xl: 128

      j2_template_name:
        backend:
          name: "backend"
        main:
          name: "vm-{{ cloud }}"

      object_name: "{{ ansible_date_time.date }}-{{ vmName }}.tf"

      vmName: "test-{{ lookup('community.general.random_string', length=5, special=false) | lower }}"
      vmCount: "1"
      vmSize: "s"
      vmTemplate: ubuntu24
      vmFirmware: "bios"
      rootFolderpath: "stuttgart-things"
      resourcePool: "/LabUL/host/Cluster-V6.5/Resources"
      backend_host_url: "https://artifacts.app1.sthings-vsphere.labul.sva.de"
      s3region: "main"

  - name: vsphere
    file: |
      ---
      vm_cpu: "{{ vm_size['cpu'][vmSize] }}"
      vm_memory: "{{ vm_size['memory'][vmSize] }}"
      vm_disk: "{{ vm_size['disk'][vmSize] }}"
      vm_template: "{{ lab_values[cloud]['template'][vmTemplate] }}"
      vm_datastores: "{{ lab_values[cloud]['datastore'] | random }}"
      vm_network: "{{ lab_values[cloud]['network'] | random }}"
      folderpath: "{{ lab_values[cloud]['subfolderpath'] }}"
      datacenter: "/LabUL"
      tf_module_source: "github.com/stuttgart-things/vsphere-vm?ref=v1.7.5-2.7.0-1"

  - name: proxmox
    file: |
      ---
      vm_cpu: "{{ vm_size['cpu'][vmSize] }}"
      vm_memory: "{{ vm_size['memory'][vmSize] }}"
      vm_disk: "{{ vm_size['disk'][vmSize] }}"
      vm_template: "{{ lab_values[cloud]['template'][vmTemplate] }}"
      vm_datastores: "{{ lab_values[cloud]['datastore'] | random }}"
      vm_network: "{{ lab_values[cloud]['network'] | random }}"
      folderpath: "{{ lab_values[cloud]['subfolderpath'] }}"
      tf_module_source: "github.com/stuttgart-things/proxmox-vm.git?ref=v2.9.14-1.5.5"
      datacenter: "sthings-pve1"

  - name: tf-vars-vsphere
    file: |
      ---
      tf_vars:
        vsphere_server: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=cloud/data/vsphere:ip validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
        vsphere_user: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=cloud/data/vsphere:username validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
        vsphere_password: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=cloud/data/vsphere:password validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
        vm_ssh_user: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=cloud/data/vsphere:vm_ssh_user validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
        vm_ssh_password: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=cloud/data/vsphere:vm_ssh_password validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"

  - name: tf-vars-proxmox
    file: |
      ---
      tf_vars:
        pve_api_url: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=cloud/data/pve:api_url validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
        pve_api_user: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=cloud/data/pve:api_user validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
        pve_api_password: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=cloud/data/pve:api_password validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
        vm_ssh_user: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=cloud/data/pve:ssh_user validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
        vm_ssh_password: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=cloud/data/pve:ssh_password validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"

  - name: terraform-vars
    file: |
      ---
      tf_project_path: "./terraform"
      state: "present"
      rendered_all: "tf-config-all.tf"
      AWS_ACCESS_KEY_ID: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=apps/data/artifacts:accessKey validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
      AWS_SECRET_ACCESS_KEY: "{{ lookup('community.hashi_vault.hashi_vault', 'secret=apps/data/artifacts:secretKey validate_certs=false auth_method=approle role_id={{ vault_approle_id }} secret_id={{ vault_approle_secret }} url={{ vault_url }}') }}"
      force_init: true
      init_reconfigure: true

  - name: s3-instances
    file: |
      ---
      instances:
        labul-automation:
          url: https://artifacts.automation.sthings-vsphere.labul.sva.de:443
          username: apps/data/artifacts:accessKey
          password: apps/data/artifacts:secretKey
        andre-dev:
          url: https://artifacts.andre-dev.sthings-vsphere.labul.sva.de:443
          username: apps/data/artifacts:accessKey
          password: apps/data/artifacts:secretKey

  - name: users
    file: |
      ---
      users:
        - username: rke
          name: rke user
          groups: ['{{ admin_group }}']
          uid: 1005
          home: /home/rke
          profile: |
            alias ll='ls -ahl'
          generate_ssh_key: true
          enable_ssh_tcp_forwarding: true

  - name: binaries
    file: |
      ---
      gh_version: 2.52.0 # datasource=github-tags depName=cli/cli
      task_version: v3.37.2 # datasource=github-tags depName=go-task/task
      hugo_version: 0.128.1 # datasource=github-tags depName=gohugoio/hugo
      terraform_version: 1.9.1 # datasource=custom.hashicorp
      packer_version: 1.11.1 # datasource=custom.hashicorp
      yq_version: 4.44.2 # datasource=github-tags depName=mikefarah/yq
      machineshop_version: 2.1.9 # datasource=github-tags depName=stuttgart-things/machineshop
      jq_version: 1.7.1 # datasource=github-tags depName=jqlang/jq

      bin:
        gh:
          bin_name: gh
          bin_version: "{{ gh_version }}"
          check_bin_version_before_installing: true
          source_url: "https://github.com/cli/cli/releases/download/v{{ gh_version }}/gh_{{ gh_version }}_linux_amd64.tar.gz"
          bin_to_copy: gh_{{ gh_version }}_linux_amd64/bin/gh
          to_remove: gh_{{ gh_version }}_linux_amd64.tar.gz
          bin_dir: "/usr/local/bin"
          version_cmd: "-- version"
          target_version: "{{ gh_version }}"
        task:
          bin_name: task
          bin_version: "{{ task_version }}"
          check_bin_version_before_installing: true
          source_url: "https://github.com/go-task/task/releases/download/{{ task_version }}/task_linux_amd64.tar.gz"
          bin_to_copy: task
          to_remove: task_linux_amd64.tar.gz
          bin_dir: "/usr/local/bin"
          version_cmd: "-- version"
          target_version: "{{ task_version }}"
        hugo:
          bin_name: hugo
          bin_version: "v{{ hugo_version }}"
          check_bin_version_before_installing: true
          source_url: "https://github.com/gohugoio/hugo/releases/download/v{{ hugo_version }}/hugo_{{ hugo_version }}_linux-amd64.tar.gz"
          bin_to_copy: "hugo"
          to_remove: "hugo"
          bin_dir: "/usr/local/bin"
          version_cmd: " --version"
          target_version: v{{ hugo_version }}
        terraform:
          bin_name: "terraform"
          bin_version: "{{ terraform_version }}"
          check_bin_version_before_installing: true
          source_url: "https://releases.hashicorp.com/terraform/{{ terraform_version }}/terraform_{{ terraform_version }}_linux_amd64.zip"
          bin_to_copy: "terraform"
          to_remove: "terraform"
          bin_dir: "/usr/local/bin"
          version_cmd: " --version"
          target_version: "{{ terraform_version }}"
        packer:
          bin_name: "packer"
          bin_version: "v{{ packer_version }}"
          check_bin_version_before_installing: true
          source_url: "https://releases.hashicorp.com/packer/{{ packer_version }}/packer_{{ packer_version }}_linux_amd64.zip"
          bin_to_copy: "packer"
          to_remove: "packer"
          bin_dir: "/usr/local/bin"
          version_cmd: " --version"
          target_version: v{{ packer_version }}
          #md5_checksum: "374f22185f1f8cb25bc53187a2154ef0"
        yq:
          bin_name: yq
          bin_version: "v{{ yq_version }}"
          check_bin_version_before_installing: true
          source_url: "https://github.com/mikefarah/yq/releases/download/v{{ yq_version }}/yq_linux_amd64.tar.gz"
          bin_to_copy: yq_linux_amd64
          to_remove: ""
          bin_dir: "/usr/bin/yq"
          version_cmd: " version"
          target_version: "v{{ yq_version }}"
        machineshop:
          bin_name: machineshop
          bin_version: "{{ machineshop_version }}"
          check_bin_version_before_installing: true
          source_url: https://github.com/stuttgart-things/machineshop/releases/download/{{ machineshop_version }}/machineshop_Linux_x86_64.tar.gz
          bin_to_copy: machineshop
          to_remove: ""
          bin_dir: "/usr/bin"
          version_cmd: " version"
          target_version: "{{ machineshop_version }}"
        jq:
          bin_name: jq
          bin_version: "v{{ jq_version }}"
          check_bin_version_before_installing: true
          source_url: "https://github.com/jqlang/jq/releases/download/jq-{{ jq_version }}/jq-linux-amd64"
          bin_to_copy: jq-linux-amd64
          to_remove: ""
          bin_dir: "/usr/bin/jq"
          version_cmd: " version"
          target_version: "v{{ jq_version }}"

modules:
  - name: get_checksum
    file: |
      #!/usr/bin/python

      DOCUMENTATION = '''
      ---
      module: get_checksum

      short_description:
        - Generate a checksum for a directory/file
        - References:
              Took some source code from https://pypi.org/project/checksumdir and converted into ansible module


      version_added: "2.6"

      description:
          - "Generate a checksum for a directory/file"

      options:
        path:
          description:
            - The full path of the file/object to get the facts of.
          required: true
        follow_links:
          description:
            - Whether to follow symlinks.
            - Only works for directory
          type: bool
          default: 'no'
        checksum_type:
          description:
            - Which checksum algorithm to use to apply to the path
          choices: ['md5', 'sha1', 'sha256', 'sha512']
          default: 'md5'
          type: str
        exclude_files:
          description:
            - The files to be excluded in the path for the checksum calculation
            - Only works for directory
          default: None
          type: list
        ignore_hidden:
          description:
            - If hidden files should be included
            - Only works for directory
          default: False
          type: bool
        exclude_extensions:
          description:
            - If certain file extensions should be ignored
            - Only works for directory
          default: None
          type: list

      author:
          - Rahul K
      '''

      EXAMPLES = '''
      # Generate Checksum Value for a directory/file
      # Default to checksum_type of md5
      - get_checksum:
          path: path/to/(directory/file)
        register:  checksum

      - debug
          msg:  'Checksum_value is {{ checksum.checksum_value }}'

      # Generate the Checksum Value with certain checksum_algorithm
      - get_checksum:
          path: path/to/directory
          checksum_type: sha1/md5/sha256/sha512
        register: checksum

      # Generate checksum value of directory excluding files
      - get_checksum:
            path: path/to/directory
            exclude_files:
              - test1
              - test2
        register: checksum

      # Generate checksum value of directory excluding certain extensions
      - get_checksum:
            path: path/to/directory
            exclude_extensions:
                - py
                - git
        register: checksum

      # Generate checksum value of directory ignoring hidden files
      - get_checksum:
            path: path/to/directory
            ignore_hidden: yes
        register: checksum

      # If the contents of sym links needs to be included
      - get_checksum:
            path: path/to/directory
            follow_symlinks: yes
        register: checksum
      '''

      RETURN = '''
      checksum_value:
          description: The checksum value generated
          type: str
      '''

      # Importing the required modules for calculating the checksum
      import os
      import hashlib
      import re

      # Importing the Ansible Module
      from ansible.module_utils.basic import *

      # Defining the methods from the hashlib library for each hashing algorithm
      HASH_FUNCS = {
          'md5': hashlib.md5,
          'sha1': hashlib.sha1,
          'sha256': hashlib.sha256,
          'sha512': hashlib.sha512
      }

      # Method to perform hashing of a directory with extra options
      def dirhash(dirname, hashfunc, exclude_files, ignore_hidden,
                  followlinks, exclude_extensions):
          hash_func = HASH_FUNCS.get(hashfunc)
          hashvalues = []
          for root, dirs, files in os.walk(dirname, topdown=True, followlinks=followlinks):
              if ignore_hidden:
                  if not re.search(r'/\.', root):
                      hashvalues.extend(
                          [_filehash(os.path.join(root, f),
                                    hash_func) for f in files if not
                          f.startswith('.') and not re.search(r'/\.', f)
                          and f not in exclude_files
                          and f.split('.')[-1:][0] not in exclude_extensions
                          ]
                      )
              else:
                  hashvalues.extend(
                      [
                          _filehash(os.path.join(root, f), hash_func)
                          for f in files
                          if f not in exclude_files
                          and f.split('.')[-1:][0] not in exclude_extensions
                      ]
                  )
          return _reduce_hash(hashvalues, hash_func)

      # Method to perform the hash of a single file
      def _filehash(filepath, hashfunc):
          hasher = hashfunc()
          blocksize = 64 * 1024
          with open(filepath, 'rb') as fp:
              while True:
                  data = fp.read(blocksize)
                  if not data:
                      break
                  hasher.update(data)
          return hasher.hexdigest()

      # Method to reduce the individual hashes of each file
      def _reduce_hash(hashlist, hashfunc):
          hasher = hashfunc()
          for hashvalue in sorted(hashlist):
              hasher.update(hashvalue.encode('utf-8'))
          return hasher.hexdigest()

      # Method for getting arguments and running the main logic
      def run_module():
          # define the available arguments/parameters that a user can pass to
          # the module
          module_args = dict(
              path=dict(required=True, type='path'),
              checksum_type=dict(type='str', default='md5',
                            choices=['md5', 'sha1', 'sha256', 'sha512']),
              exclude_files=dict(type='list', default=[]),
              exclude_extensions=dict(type='list', default=[]),
              ignore_hidden=dict(type='bool', default=False),
              follow_links=dict(type='bool', default=False),
          )

          # seed the result dict in the object
          # we primarily care about changed and state
          # change is if this module effectively modified the target
          # state will include any data that you want your module to pass back
          # for consumption, for example, in a subsequent task
          result = dict(
              changed=False,
              checksum_value=''
          )

          # the AnsibleModule object will be our abstraction working with Ansible
          # this includes instantiation, a couple of common attr would be the
          # args/params passed to the execution, as well as if the module
          # supports check mode
          module = AnsibleModule(
              argument_spec=module_args,
              supports_check_mode=True
          )

          # if the user is working with this module in only check mode we do not
          # want to make any changes to the environment, just return the current
          # state with no modifications
          if module.check_mode:
              return result

          # Store the passed arguments in variables
          path = module.params['path']
          checksum_type = module.params['checksum_type']
          exclude_files = module.params['exclude_files']
          exclude_extensions = module.params['exclude_extensions']
          ignore_hidden = module.params['ignore_hidden']
          follow_links = module.params['follow_links']

      # Check if the path is a directory and calculate checksum
          if os.path.isdir(path):
              result['checksum_value'] = dirhash(path, checksum_type, exclude_files,
                                        ignore_hidden, follow_links, exclude_extensions)

      # Check if the path is a file and calculate the checksum
          elif os.path.isfile(path):
              hasher = HASH_FUNCS.get(checksum_type)
              result['checksum_value'] = _filehash(path, hasher)

      # Fail if its neither a file nor a directory
          else:
              result['failed'] = True
              error = '{} is not a valid path.'.format(path)
              module.fail_json(msg=error, meta=result)

          # in the event of a successful module execution, you will want to
          # simple AnsibleModule.exit_json(), passing the key/value results
          result['changed'] = True
          module.exit_json(**result)

      def main():
          run_module()

      if __name__ == '__main__':
          main()
